# 主程序入口
import os
import torch
import numpy as np
import matplotlib.pyplot as plt
from configs.default import Config
from src.data_loader import StockDataLoader
from src.model import LSTMModel
from src.trainer import StockTrainer
from src.utils.visualize import plot_training_history, plot_predictions


def main():
    # 初始化配置
    config = Config()
    os.makedirs(f"{config.save_dir}/models", exist_ok=True)
    os.makedirs(f"{config.save_dir}/figures", exist_ok=True)

    # 加载数据
    loader = StockDataLoader(config)
    df = loader.load_local_data()
    X, y = loader.preprocess_data(df)
    train_data, val_data, test_data = loader.split_data(X, y)

    # 初始化模型
    model = LSTMModel(
        input_size=len(config.features),
        hidden_size=config.hidden_size,
        num_layers=config.num_layers
    )

    # 开始训练
    trainer = StockTrainer(config, model, (train_data, val_data, test_data))
    trainer.run()

    # 可视化训练过程
    plot_training_history(trainer.history, f"{config.save_dir}/figures")

    # 测试集预测
    model.load_state_dict(torch.load(f"{config.save_dir}/models/best_model.pth"))
    model.eval()
    with torch.no_grad():
        test_X = torch.FloatTensor(test_data[0]).to(config.device)
        preds = model(test_X).cpu().numpy()


    #     # 反归一化
    #     # 确保输入数据的形状与 scaler 的期望形状一致
    #     test_X_np = test_X.cpu().numpy()  # 将张量转换为 NumPy 数组
    #     test_X_reshaped = test_X_np.reshape(-1, len(config.features))  # 重塑为 (batch_size * seq_length, input_size)
    #
    #     # 调整 test_data[0] 的形状
    #     test_X_last_step = test_data[0][:, -1, :]  # 取每个样本的最后一个时间步
    #     test_X_last_step = test_X_last_step.reshape(-1, len(config.features))  # 重塑为 (batch_size, input_size)
    #
    #
    #     # 反归一化预测值
    #     predicted = loader.scaler.inverse_transform(
    #         np.concatenate([test_X_reshaped, preds.reshape(-1, 1)], axis=1)
    #     )[:, -1]
    #
    #
    #
    #
    # # 反归一化实际值
    # actual = loader.scaler.inverse_transform(
    #     np.concatenate([test_data[0][:, -1, :], test_data[1].reshape(-1, 1)], axis=1)
    # )[:, -1]
    # predicted = loader.scaler.inverse_transform(
    #     np.concatenate([test_data[0][:, -1, :], preds.reshape(-1, 1)], axis=1)
    # )[:, -1]


    # 提取最后一个时间步的特征
    test_X_last_step = test_data[0][:, -1, :]  # 形状为 (batch_size, input_size)

    # 打印形状以验证维度
    print(f"test_X_last_step shape: {test_X_last_step.shape}")  # 应输出 (batch_size, input_size)
    print(f"test_data[1] shape: {test_data[1].shape}")  # 应输出 (batch_size,)
    print(f"preds shape: {preds.shape}")  # 应输出 (batch_size,)

    # 反归一化实际收盘价和预测收盘价

    # # 反归一化实际收盘价
    # actual_close = loader.scaler.inverse_transform(
    #     np.concatenate([test_X_last_step, test_data[1].reshape(-1, 1)], axis=1)
    # )[:, -1]

    # 直接使用原始的真实值（假设 test_data[1] 是原始的收盘价）
    actual_close = test_data[1]  # 真实值

    # # 反归一化预测收盘价
    # predicted_close = loader.scaler.inverse_transform(
    #     np.concatenate([test_X_last_step, preds.reshape(-1, 1)], axis=1)
    # )[:, -1]

    # 反归一化预测值
    preds_reshaped = preds.reshape(-1, 1)  # 将 preds 的形状从 (92,) 调整为 (92, 1)
    predicted_close = loader.scaler.inverse_transform(preds_reshaped).flatten()  # 反归一化并展平


    print("actual_close:", actual_close)
    print("predicted_close:", predicted_close)
    #plt.plot(actual_close, label="Actual")


    # 绘制对比图
    plt.figure(figsize=(10, 6))
    plt.plot(actual_close, label="Actual Close Price")
    plt.plot(predicted_close, label="Predicted Close Price")
    plt.legend()
    plt.title("Actual vs Predicted Close Price")
    plt.xlabel("Time Step")
    plt.ylabel("Price")
    plt.show()

    # # 绘制预测对比图
    # plot_predictions(actual, predicted, f"{config.save_dir}/figures")
# # 绘制预测对比图
#     plot_predictions(actual_close, predicted_close, f"{config.save_dir}/figures")
#
# plt.figure(figsize=(10, 6))
# plt.plot(actual_close, label="Actual")
# plt.plot(preds, label="Predicted")
# plt.legend()
# plt.show()

if __name__ == "__main__":
    main()